---
title: "Differential Expression"
author: "Nadine Bestard"
date: "21/07/2021"
output:
  html_document:
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### set-up
```{r message=FALSE, warning=FALSE}
library(scran) # for scDE
library(scater) # for aggregate counts
library(edgeR) #for De
library(here) # reproducible paths
library(DropletUtils) # ambient RNA
library(scuttle) # modify gene names
```

```{r load}
source(here("src/colours.R"))
project <- "de_tests"
sce <- readRDS(here("processed", "fire-mice", "sce_anno_02.RDS")) #TODO: change back to "project"
clusters_name <- "clusters_named"
```


## Use of pseudo-bulk samples

We perform the DE analysis separately for each label to identify cell type-specific transcriptional effects of KO condition. The actual DE testing is performed on “pseudo-bulk” expression profiles (Tung et al. 2017), generated by summing counts together for all cells with the same combination of label and sample. This leverages the resolution offered by single-cell technologies to define the labels, and combines it with the statistical rigor of existing methods for DE analyses involving a small number of samples.

```{r sum}
# each column represents unique combination for each cluster and each sample replicate
summed <- aggregateAcrossCells(sce, 
                               id=colData(sce)[,c(clusters_name, "Sample")]) 
summed
```

## Perform DE

### Filter replicates that do not have enough cells

We first filter out all the combinations sample-label that resulted in less than 10
cells. These are saved in /outs/`r project`/DE_cluster/fail_min_cells_DE.csv

```{r filter-summed}
# Removing all pseudo-bulk samples with 'insufficient' cells.
summed_filt <- summed[, summed$ncells >= 10]

# and saving to file which one there are
fail_n_cells  <- colData(summed)[ colData(summed)$ncells < 10, c("Sample", "mouse", "genotype", "tissue", "chip", clusters_name, "ncells")]

write.csv(fail_n_cells, here("outs", project,"DE_edgeR", "fail_min_cells_DE.csv"), row.names = FALSE)
```

### Design 

`tissue` and `chip` are confounded, meaning it is not possible to correct for both; and seen there is greater variation in `chip` than `tissue` correcting for `chip` seems more sensible.

```{r}
table(sce$tissue, sce$chip)
table(sce$genotype, sce$chip)
table(sce$genotype, sce$tissue)
design=~factor(chip) + genotype
sce$chip <- factor(sce$chip)
design_KOvsHET=~0+ chip + genotype
```

We then compute the DE with edgeR, one of the best methods according to [(Soneson et al. 2018)](https://www.nature.com/articles/nmeth.4612). The results are saved in /outs/`r project`/DE_edgeR/de_results

**Output:**

LogFC is the log fold-change, which is the log difference between both groups

LogCPM are the log counts per million, which can be understood as measuring expression level.

F is the F-statistic from the quasi-likelihood F-test.

PValue is the nominal p-value derived from F without any multiple testing correction

FDR (False discovery rate) is the PValue after Benjamini-Hochberg correction.  For example, the set of genes with adjusted p value less than 0.1 should contain no more than 10% false positives.

If the comparison was not possible for a particular cluster, most commonly due to lack of residual degrees of freedom ( e.g. an absence of enough samples from both conditions) it is listed in /outs/`r project`/DE_edgeR/fail_min_cells_DE.csv

```{r de, eval=TRUE}
# Reordering the genotype factor, treated should be second level
summed_filt$genotype <- factor(summed_filt$genotype, levels = c("WT", "HET", "KO"))

# KO ones
# run de
de_results_KO <- pseudoBulkDGE(summed_filt, 
                               label=summed_filt$clusters_named,
                               design= design,
                               coef="genotypeKO",
                               condition=summed_filt$genotype 
)

# HET ones
de_results_HET <- pseudoBulkDGE(summed_filt, 
                                label=summed_filt$clusters_named,
                                design= design,
                                coef="genotypeHET",
                                condition=summed_filt$genotype 
)
# KOvsHET ones
de_results_KOvsHET <- pseudoBulkDGE(summed_filt, 
                                    label=summed_filt$clusters_named,
                                    design= design_KOvsHET,
                                    contrast=c("genotypeKO - genotypeHET"),
                                    condition=summed_filt$genotype 
)

# create a list to loop through the 3 de_results
de_results <- list(KO=de_results_KO, HET=de_results_HET, KOvsHET=de_results_KOvsHET)
for (gnt in c("KO", "HET", "KOvsHET")) {
    #extract each genotype dataframe list
  de_results_gnt <- de_results[[gnt]]
  
  #save R objects
  dir.create(here("processed",project), showWarnings = FALSE)
  saveRDS(de_results_gnt, here("processed",project, paste0("DE_results_edgeR_", gnt, ".RDS")))
}
```

## Filter ambient RNA background

Extracellular RNA (most commonly released upon cell lysis) is captured along with each cell in its reaction chamber, contributing counts to genes that are not otherwise expressed in that cell. This is problematic for DE analyses between conditions, as DEGs detected for a particular cell type may be driven by differences in the ambient profiles rather than any intrinsic change in gene regulation. Here he observed microglia genes are shown as down regulated in cell types were their expression is not expected (such as oligodendrocytes and astrocytes).
We will use these known genes as previous knowledge to build an ambient model and remove it from the DE. 

The list of microglia genes used are in top 100 of middle-aged microglia markers and significantly down in at least one cluster in young and/or middle-aged datasets.

```{r background, eval=TRUE}

# to calculate the ambient the raw data should be used
samples <- dir(here("data/raw/"))
# create empty vector to hold ambient
ambient <- vector("list", length(samples))
names(ambient) <- samples
# generate profile for each sample
for(sample in samples){
  matrix <- here("data/raw/", sample, "raw_feature_bc_matrix")
  sce_sample <- read10xCounts(matrix, sample, version = "auto", col.names = TRUE)
  # calculate ambient counts, with good turning FALSE because we will use the counts for further estimations and round false because we already have integers. 
  ambient[[sample]] <- ambientProfileEmpty(counts(sce_sample), good.turing = FALSE, round = FALSE)
}

# clean up ambient output
ambient <-  do.call(cbind, ambient)

# use symbol nomenclature
rownames(ambient) <- uniquifyFeatureNames(
  ID=rowData(sce_sample)$ID,
  names=rowData(sce_sample)$Symbol
)

# maximum proportion for each gene that could be due to ambient
# I need here to sort out the ambient vecotr, so I can do the 19 clusters at once, repeating n (often 12) times
# the ambient profile. the ambient profile needs to be calculated on groups of cells that are similar: We'll use 
# the clusters we run the DEG on, like this it can be added to each of these. It also needs to run per sample (obviously you don't calculate the ambient with another sample), but we can take for each gene the avareage of the proportion obtained in each sample. For this again we will need to sort out the fact I'm doing this for all clusters at once, as we only want to average for each cluster. 

# create an aggregate ambient, duplicating the information to match the format of the summed sce
n=0
aggregate_ambient <- matrix(nrow = nrow(ambient), ncol=ncol(summed_filt))
for( sample in summed_filt$Sample){
  n = n+1
  aggregate_ambient[,n] <-  ambient[,sample]
}
# add the gene names again
rownames(aggregate_ambient) <- rownames(ambient)

# subset for same genes as in the summed sce
aggregate_ambient <- aggregate_ambient[row.names(summed_filt),]

# upper bound of gene contribution from ambient contamination
max_ambient <- ambientContribMaximum(counts(summed_filt), ambient= aggregate_ambient, mode = "proportion")
la
# mean of result obtained between all samples -> needs to be done for each cluster

# create a list to hold the updated DFs ( i tried with lapply but not there yet)
de_results_ambient <- list(KO="", HET="", KOvsHET="")
for (gnt in c("KO", "HET", "KOvsHET")) {
    #extract each genotype dataframe list
  de_results_gnt <- de_results[[gnt]]
  
  # add to the list of dataframes with results for each cluster the ambient info
  de_result_gnt_ambient <- lapply(names(de_results_gnt), function(cluster) {
    de_results_clu <- de_results_gnt[[cluster]]
    # calculate mean of all samples for that cluster
    cluster_max_ambient <- rowMeans(max_ambient[, summed_filt$clusters_named == cluster], na.rm = TRUE)
    # combine with previous dataframe
    cbind(de_results_clu, maxAmbient = cluster_max_ambient)
  })
  names(de_result_gnt_ambient) <- names(de_results_gnt)
   # save in the genotypes list
  de_results_ambient[[gnt]] <- de_result_gnt_ambient
}

```

## Save, filter and summarised the results

For each one of the labels a list is produced with the DE genes at a FDR of 5%. Summaries of these results are saved in /outs/`r project`/DE_edgeR/ 

Values of 1, -1 and 0 indicate that the gene is significantly upregulated, downregulated or not significant, respectively.
Genes listed as NA were either filtered out as low-abundance genes for a given label’s analysis, or the comparison of interest was not possible for that particular label.

de_filtered_genecounts.csv contains a small summary with the number of genes DE for each one of the clusters. 

de_filtered_genes.csv contains the list of genes DE. 

```{r save-de, eval=TRUE, warning=FALSE}
## SAVE per cluster 

for(gnt in c("KO", "HET", "KOvsHET")){
  
  #extract each table
  de_results_gnt <- de_results_ambient[[gnt]]

  #save R objects
  dir.create(here("processed",project), showWarnings = FALSE)
  saveRDS(de_results_gnt, here("processed",project, paste0("DE_results_ambient_edgeR_", gnt, ".RDS")))

  
   # save results DE tables, diferent files for each cluster
   lapply(names(de_results_gnt), function(cluster){
     de_results_clu <- de_results_gnt[[cluster]]
     dir.create(here("outs", project, "DE_edgeR", paste0("de_results_", gnt)), showWarnings = FALSE)
     write.csv(de_results_clu, here("outs", project, "DE_edgeR", paste0("de_results_", gnt), paste0("de_results_", gnt, "_", cluster, ".csv")), quote = FALSE)
   }
   )
   # save failed test
   write.csv(metadata(de_results_gnt), here("outs", project,"DE_edgeR", paste0("fail_contrast_DE_",gnt,".csv")), row.names = FALSE)
            
}
```


```{r filter-de, eval=FALSE}
## FILTER and SUMMARISE
de_results <- list(KO=de_results_KO, HET=de_results_HET, KOvsHET=de_results_KOvsHET)
cols <- list(KO=col_wt_het_ko[3], HET=col_wt_het_ko[2], WT=col_wt_het_ko[1])
for(gnt in c("KO", "HET", "KOvsHET")){
  
  de_results_gnt <- de_results[[gnt]]
  is_de <- decideTestsPerLabel(de_results_gnt, threshold=0.05)
  summary_de <- summarizeTestsPerLabel(is_de)
  
  # virtually 0 or NA we do not care, we want only + or -
  is_de_0 <- is_de
  is_de_0[is.na(is_de_0)]<- 0
  # but filter the original object to get them back
  is_de_flt <- is_de[(rowSums(abs(is_de_0)) != 0), ]
  
  write.csv(summary_de, here("outs", project,"DE_edgeR", paste0( "de_", gnt, "_filtered_genecounts.csv")))
  write.csv(is_de_flt, here("outs", project, "DE_edgeR", paste0( "de_", gnt, "_filtered_genes.csv" )))
}

```


## Plot the results

Saved in /outs/`r project`/DE_edgeR/de_filtered_plots


```{r plot, eval=FALSE}
for(gnt in c("KO", "HET", "KOvsHET")){
  # read the filtered table
  is_de_flt <-  read.csv(here("outs", project, "DE_edgeR", paste0( "de_", gnt, "_filtered_genes.csv" ))
                         
                         # plots
                         dir.create(here("outs", project, "DE_edgeR", "plots", paste0( "de_", gnt, "_filtered_plots")))
                         is_de_genes <- rownames(is_de_flt)
                         for( gene in is_de_genes){
                           pdf(file = here("outs", project, "DE_edgeR", "plots", paste0( "de_", gnt, "_filtered_plots"), paste0(gene, ".pdf")))
                           plot <- plotExpression(logNormCounts(sce),
                                                  features=gene,
                                                  x="genotype", colour_by="genotype",
                                                  other_fields="clusters_named") +
                             facet_wrap(~clusters_named) +
                             scale_color_manual(values = col_wt_het_ko) +
                             ggtitle(gene)
                           print(plot)
                           dev.off()
                         }
                         
}
```

<details>
<summary>**Session Info**</summary>

```{r}
sessionInfo()
```

</details>


